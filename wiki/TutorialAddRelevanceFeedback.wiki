#summary A tutorial on adding relevance feedback.

= Introduction =

This tutorial shows how to add support for (explicit) relevance feedback to UCAIR. Relevance feedback allows user to explicitly specify whether a document is relevant or not, and uses this information to help rerank the unjudged documents.

= Step 1: UI for relevance judgment =

In this step we'll change the HTML to display clickable links that can be used to provide relevance judgment. There is a "Y" link to indicate positive relevance, a "N" link to indicate negative relevance, and an initially hidden "C" link to cancel previous made relevance judgment:

[http://code.google.com/p/ucair/source/diff?spec=svn22&r=22&format=side&path=/trunk/templates/result_list_view.htm result_list_view.htm]
{{{
<span class="search_result_rating" style="display:none">${rating}</span>
<span class="search_result_rating_y">Y</span>
<span class="search_result_rating_n">N</span>
<span class="search_result_rating_c">C</span>
<span class="search_result_rating_url" style="display:none">/rate?sid=${search_id}&amp;pos=${result_pos}&amp;view=${view_id}&amp;rating=</span>
}}}

I use a hidden `span.search_result_rating` element to hold the current rating, and a hidden `span.search_result_rating_url` element to hold the url for rating submission.

Note the use of template variables such as ${search_id} and ${result_pos}. These are replaced by actual values when the HTML pages are rendered. I have written a custom C++ based template engine ([http://code.google.com/p/ucair/source/browse/trunk/UCAIR09/template_engine.h template_engine.h] [http://code.google.com/p/ucair/source/browse/trunk/UCAIR09/template_engine.cpp .cpp]) that provides somewhat comparable functionality as JSP/PHP. 

Following is associated CSS:

[http://code.google.com/p/ucair/source/diff?spec=svn22&r=22&format=side&path=/trunk/static_files/main.css main.css]
{{{
.search_result_rating_y, .search_result_rating_n, .search_result_rating_c{
        color: #7777CC;
        margin-left: 5px;
        margin-right: 5px;
        padding-left: 2px;
        padding-right: 2px;
        text-decoration: underline;
        cursor: pointer;
}

.search_result_rating_y.rated {
        color: #007700;
        background-color: #F0F0F0;
        font-weight: bold;
        text-decoration: none;
        cursor: auto;
}

.search_result_rating_n.rated {
        color: #770000;
        background-color: #F0F0F0;
        font-weight: bold;
        text-decoration: none;
        cursor: auto;
}
}}}

We change the colors when they are assigned a `rated` class.

Finally there is the Javascript (I use [http://jquery.com/ JQuery]):

[http://code.google.com/p/ucair/source/diff?spec=svn22&r=22&format=side&path=/trunk/static_files/main.js main.js]
{{{
function prepareRatings() {
        $(".search_result_rating").each(function() {
                var ratingElem = $(this);
                showRating(ratingElem, false);
                var y = ratingElem.nextAll(".search_result_rating_y");
                var n = ratingElem.nextAll(".search_result_rating_n");
                var c = ratingElem.nextAll(".search_result_rating_c");
                y.click(function() {
                        ratingElem.text("Y");
                        showRating(ratingElem, true);
                });
                n.click(function() {
                        ratingElem.text("N");
                        showRating(ratingElem, true);
                });
                c.click(function() {
                        ratingElem.text("");
                        showRating(ratingElem, true);
                });
        });
}

function showRating(ratingElem, sendRating) {
        var y = ratingElem.nextAll(".search_result_rating_y");
        var n = ratingElem.nextAll(".search_result_rating_n");
        var c = ratingElem.nextAll(".search_result_rating_c");
        var val = ratingElem.text();
        if (val == "Y") {
                y.addClass("rated").show();
                n.removeClass("rated").hide();
                c.show();
        }
        else if (val == "N") {
                y.removeClass("rated").hide();
                n.addClass("rated").show();
                c.show();
        }
        else {
                y.removeClass("rated").show();
                n.removeClass("rated").show();
                c.hide();
        }
        if (sendRating) {
                var url = ratingElem.nextAll(".search_result_rating_url").text();
                $.get(url + encodeURI(val));
        }
}
}}}

When "Y" is clicked, the following happens:
 # rating inside the ".search_result_rating" element is set to "Y"
 # "Y" is highlighted by setting the `rated' class
 # "N" becomes hidden
 # "C" becomes visible
 # We send an AJAX request to the server (`$.get`) using the url `/rate?sid=${search_id}&amp;pos=${result_pos}&amp;view=${view_id}&amp;rating=Y`

Similar things happen when "N" is clicked.

`prepareRatings` is also called during page load: [http://code.google.com/p/ucair/source/diff?spec=svn22&r=22&format=side&path=/trunk/templates/basic_search.htm basic_search.htm]

= Step 2: Record the relevance judgment at server side =

Whenever we receive an AJAX request indicating a document is relevant or not, we need to store this relevance judgment for later use.

First, we register a handler for the AJAX request:
[http://code.google.com/p/ucair/source/diff?spec=svn22&r=22&format=side&path=/trunk/UCAIR09/basic_search_ui.cpp basic_search_ui.cpp]
{{{
getUCAIRServer().registerHandler(RequestHandler::CGI_OTHER, "/rate", bind(&BasicSearchUI::rateResult, this, _1, _2));
}}}

The handler type is `CGI_OTHER`. We use `CGI_HTML` for CGI handlers that dynamically generate HTML pages, and `CGI_OTHER` for other CGI handlers that do not generate HTML pages. Both types of handlers parse params from URL and POST data.

The handler will invoke `BasicSearchUI::rateResult` whenever the request URL starts with `/rate`. The `Request` object is passed as the 1st arg, and the `Reply` object is passed as the 2nd arg.

Now let's look at the handler itself:

[http://code.google.com/p/ucair/source/diff?spec=svn22&r=22&format=side&path=/trunk/UCAIR09/basic_search_ui.cpp basic_search_ui.cpp]
{{{
void BasicSearchUI::rateResult(Request &request, Reply &reply){
        User *user = getUserManager().getUser(request, true);
        assert(user);

        int result_pos = 0;
        try{
                string s = request.getFormData("pos");
                if (! s.empty()){
                        result_pos = lexical_cast<int>(s);
                }
        }
        catch (bad_lexical_cast &){
                getUCAIRServer().err(reply_status::bad_request);
        }
        string rating = request.getFormData("rating");

        string search_id = request.getFormData("sid");
        string view_id = request.getFormData("view");
        const SearchResult *result = getSearchProxy().getResult(search_id, result_pos);
        if (result){
                // Adds an event of user explicitly rating the result.
                shared_ptr<RateResultEvent> event(new RateResultEvent);
                event->search_id = search_id;
                event->result_pos = result_pos;
                event->rating = rating;
                user->addEvent(event);

                UserSearchRecord *search_record = user->getSearchRecord(search_id);
                if (search_record){
                        search_record->setResultRating(result_pos, rating);
                        // Mark all previous search results as viewed.
                        const string property_name = "ranking_" + view_id;
                        if (search_record->properties.has(property_name)){
                                vector<int> &ranking = search_record->properties.get<vector<int> >(property_name);
                                BOOST_FOREACH(const int &pos, ranking){
                                        search_record->addViewedResult(pos);
                                        if (pos == result_pos){
                                                break;
                                        }
                                }
                        }
                }
        }


        // Empty reply
        reply.setHeader("Content-Type", "text/plain");
}
}}}